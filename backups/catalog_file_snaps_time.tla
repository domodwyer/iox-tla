In this spec, backup strategies that rely on wall clocks are validated.

It validates the refined proposal:

    A snapshot should contain the set of "current" files, and any file that has
    been "soft-deleted" in the last second. This 1 second delay is the
    "soft-delete grace period".

It does not model replica lag, and assumes a single clock source that
monotonically ticks. Accounting for potential clock and replica issues adds
significant complexity in the end design.

---------------------- MODULE catalog_file_snaps_time ----------------------

EXTENDS TLC, Integers

CONSTANTS
    N,          \* Bounds file creation to a maximum of N files.
    MAX_TIME    \* Bounds the amount of time ticks modelled.

VARIABLES
    timestamp,      \* The current logical integer timestamp
    next_file_id,   \* The monotonic ID assigned to the next "created" file.
    c_current,      \* The set of non-deleted files currently in the catalog.
    c_deleted,      \* The set of soft-deleted tuples: (deleted_at, file_id)
    restore_points, \* A set of tuples; the set of (backup_timestamp, files) in each catalog restore point.
    snapshots,      \* A set of tuples; the set of (snapshot_timestamp, file) sets.
    s3,             \* The set of files in object storage, without timestamp.
    last_restore_point_ts \* Timestamp of the last restore point creation.

vars == <<
    timestamp,
    next_file_id,
    c_current,
    c_deleted,
    restore_points,
    last_restore_point_ts,
    snapshots,
    s3
>>


\* Extract the file IDs from a set of (timestamp, file_id) tuples.
IdSetFromTupleSet(set) == { s[2]: s \in set }

\* The set of all possible files generated by the system.
AllPossibleFileIDs == 0..(N-1)

\* Return the set of all files across all current snapshots.
AllSnapshotFiles == UNION IdSetFromTupleSet(snapshots)

\* Preconditions that are true when the action has occurred this tick.
SnapshotHappened == \E s \in snapshots: s[1] = timestamp
RestorePointHappened == \E p \in restore_points: p[1] = timestamp

\* The set of soft-deleted tuples where the file was deleted since the last
\* restore point.
SoftDeletedSinceRP == {f \in c_deleted: f[1] >= last_restore_point_ts}

----------------------------------------------------------------------------

AddNewFile ==
    /\ next_file_id < N \* Model bound
    /\ next_file_id' = next_file_id + 1
    /\ c_current' = c_current \union {next_file_id}
    /\ s3' = s3 \union {next_file_id}
    /\ UNCHANGED <<
        timestamp,
        c_deleted,
        restore_points,
        last_restore_point_ts,
        snapshots >>

SoftDeleteFile ==
    /\ c_current /= {}
    /\ \E f \in c_current:
        /\ c_current' = c_current \ {f}
        /\ c_deleted' = c_deleted \union {<<timestamp, f>>}
    /\ UNCHANGED <<
        timestamp,
        next_file_id,
        restore_points,
        last_restore_point_ts,
        snapshots,
        s3 >>

\* A GC run removes all eligible soft-deleted files from the catalog.
GC_Catalog ==
    /\ c_deleted /= {}
    \* Keep all the soft-deleted files since the last restore point.
    /\ c_deleted' = SoftDeletedSinceRP
    /\ UNCHANGED <<
        timestamp,
        next_file_id,
        c_current,
        restore_points,
        last_restore_point_ts,
        snapshots,
        s3 >>

GC_S3 ==
    /\ s3 /= {}
    /\ s3' = {
            f \in s3:
                \* Retain these sets of files and delete everything else.
                \/ f \in c_current \union IdSetFromTupleSet(c_deleted)
                \/ f \in AllSnapshotFiles
        }
    /\ UNCHANGED <<
        timestamp,
        next_file_id,
        c_current,
        c_deleted,
        restore_points,
        last_restore_point_ts,
        snapshots >>

\* A file list is generated from the files in the catalog.
TakeSnapshot ==
    /\ restore_points /= {} \* At least one restore point must exist.
    /\ ~SnapshotHappened    \* At most one per snapshot per tick
    /\ c_current /= {}      \* Must be something to snapshot
    /\ snapshots' = snapshots \union { <<timestamp,
            \* Include all non-deleted files in the catalog.
            c_current \union
            \* Include all soft-deleted files since the last restore point.
            IdSetFromTupleSet(SoftDeletedSinceRP)
        >>}
    /\ UNCHANGED <<
        timestamp,
        next_file_id,
        c_current,
        c_deleted,
        restore_points,
        last_restore_point_ts,
        s3 >>

\* Create a new catalog restore point.
\*
\* A catalog can be "rolled back" to a state that contains one of these file
\* sets.
NewRestorePoint ==
    /\ c_current /= {}
    /\ restore_points' = restore_points \union {<<timestamp, c_current>>}
    /\ last_restore_point_ts' = timestamp
    /\ UNCHANGED <<
        timestamp,
        next_file_id,
        c_current,
        c_deleted,
        snapshots,
        s3 >>

Tick ==
    /\ RestorePointHappened
    /\ timestamp < MAX_TIME \* model bound
    /\ timestamp' = timestamp + 1
    /\ UNCHANGED <<
        next_file_id,
        c_current,
        c_deleted,
        restore_points,
        last_restore_point_ts,
        snapshots,
        s3 >>

Init ==
    /\ timestamp = 0
    /\ next_file_id = 0
    /\ c_current = {}
    /\ c_deleted = {}
    /\ restore_points = {}
    /\ last_restore_point_ts = -1
    /\ snapshots = {}
    /\ s3 = {}

Next ==
    \/ Tick
    \/ AddNewFile
    \/ TakeSnapshot
    \/ NewRestorePoint
    \/ SoftDeleteFile
    \/ GC_Catalog
    \/ GC_S3


Spec == Init /\ [][Next]_vars /\ WF_vars(Next)

----------------------------------------------------------------------------

\* All files referenced by all snapshots exist in S3 (Invariant 1).
AllSnapshotFilesExist == UNION IdSetFromTupleSet(snapshots) \subseteq s3

\* All files referenced by restore points that also have a snapshot exist in S3
\* (Invariant 2).
AllInterestingRestorePointFilesExist == \A s \in snapshots:
    \E r \in restore_points:
        /\ \/ r[1] = s[1]   \* Matches the restore point in the same tick as the snapshot.
           \/ r[1] = s[1]-1 \* Matches the restore point in the previous tick as the snapshot.
        \* The restore point files exist in s3
        /\ r[2] \subseteq s3
        \* And the restore point files are part of this snapshot.
        /\ r[2] \subseteq s[2]

\* All files in the catalog (inclusive of soft-deleted files) exist in S3.
AllFilesInCatalogExist == (c_current \union IdSetFromTupleSet(c_deleted)) \subseteq s3

TypeOk ==
    /\ timestamp \in 0..MAX_TIME
    /\ last_restore_point_ts \in -1..timestamp
    /\ next_file_id \in 0..N
    /\ c_current \subseteq (0..next_file_id)
    /\ c_deleted \subseteq (0..timestamp) \X (0..next_file_id)
    /\ IdSetFromTupleSet(c_deleted) \intersect c_current = {}
    /\ restore_points \subseteq (0..timestamp) \X (SUBSET (0..next_file_id))
    /\ snapshots \subseteq (0..timestamp) \X (SUBSET (0..next_file_id))
    /\ s3 \subseteq (0..next_file_id)

----------------------------------------------------------------------------

\* Snapshots happen in all behaviours, or the model bounds are reached first.
SnapshotLiveness == ~[](
    /\ snapshots = {}
    /\ timestamp = MAX_TIME
    /\ next_file_id = N
)

\* Soft deletions occur in all behaviours.
SoftDeleteLiveness == <>[](c_current = {})

\* It is eventually always true that the model terminates (due to reaching the
\* model bound) and the set of files in S3 is equal to all files.
\*
\* Any system that allows file deletions should violate this property.
AllFilesRetained == <>[](s3 = AllPossibleFileIDs)

=============================================================================
\* Author: Dom <dom@itsallbroken.com>

