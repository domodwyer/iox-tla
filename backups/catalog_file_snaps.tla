This model explores backup strategies that have no dependence on wall clocks.

This model describes the scenario where the snapshot interval is
less-than-or-equal-to the GC soft delete -> hard delete delay, meaning one or
more snapshots is always generated for every file that is soft-deleted, before
it is hard-deleted.

No invariant is violated using either the "retain all soft-deleted files" or the
"retain soft-deleted files since last snapshot" strategy.

However the model fails to violate the AllFilesRetained temporal property,
indicating no behaviour exists where a file is deleted. If the snapshot
frequency is not greater than the delay between soft -> hard deletion, then
every file exists in multiple snapshots in the "soft deleted" state - no file is
ever deleted!

**Outcome:** there is no benefit to implementing either proposal (we actually
add a minor cost) until the snapshot interval is greater than the GC soft->hard
deletion delay.

------------------------- MODULE catalog_file_snaps -------------------------

EXTENDS TLC, Integers

CONSTANTS
    N \* Bounds file creation to a maximum of N files.

VARIABLES
    c_current,        \* The set of non-deleted files currently in the catalog.
    c_deleted,        \* The set of soft-deleted files currently in the catalog.
    restore_points,   \* A set of sets; the set of files in each catalog restore point.
    snapshots,        \* A set of sets; the set of snapshot file sets.
    s3,               \* The set of files in object storage.
    next_file_id,     \* The monotonic ID assigned to the next "created" file.
    since_snap,       \* The set of files soft-deleted since the last snapshot.
    has_restore_point \* Ensure restore points are created more frequently than snapshots.

vars == <<
    c_current,
    c_deleted,
    restore_points,
    snapshots,
    next_file_id,
    s3,
    since_snap,
    has_restore_point
>>

\* The set of all possible files generated by the system.
AllPossibleFiles == 0..(N-1)

\* Return the set of all files in the catalog (inclusive of soft-deleted files)
AllCatalogFiles == c_current \union c_deleted

\* Return the set of all files across all snapshots.
AllSnapshotFiles == UNION snapshots

----------------------------------------------------------------------------

AddNewFile ==
    /\ next_file_id < N \* Model bounds
    /\ next_file_id' = next_file_id + 1
    /\ c_current' = c_current \union {next_file_id}
    /\ s3' = s3 \union {next_file_id}
    /\ UNCHANGED << c_deleted, restore_points, snapshots, since_snap, has_restore_point >>

SoftDeleteFile ==
    /\ \E f \in c_current:
        /\ c_current' = c_current \ {f}
        /\ c_deleted' = c_deleted \union {f}
        \* Track that this soft deletion has happened since the last snapshot.
        /\ since_snap' = since_snap \union {f}
    /\ UNCHANGED << restore_points, snapshots, next_file_id, s3, has_restore_point >>

\* A GC run removes all eligible soft-deleted files from the catalog.
GC_Catalog ==
    /\ c_deleted' = { f \in c_deleted: f \in since_snap }
    /\ UNCHANGED <<
        c_current,
        restore_points,
        snapshots,
        next_file_id,
        s3,
        since_snap,
        has_restore_point >>

GC_S3 ==
    /\ s3' = {
            f \in s3:
                \/ f \in AllCatalogFiles
                \/ f \in AllSnapshotFiles
        }
    /\ UNCHANGED <<
        c_current,
        c_deleted,
        restore_points,
        snapshots,
        next_file_id,
        since_snap,
        has_restore_point >>

\* A file list is generated from the non-soft-deleted files in the catalog.
TakeSnapshot ==
    /\ has_restore_point
    /\ has_restore_point' = FALSE \* Restore points are created in between snaps.
    /\ c_current /= {}
    /\ snapshots' = snapshots \union {
            \* The snapshot contains all the non-deleted files, and the
            \* soft-deleted files that have been marked deleted since the last
            \* snapshot.
            c_current \union c_deleted
        }
    /\ since_snap' = {}
    /\ UNCHANGED <<
        c_current,
        c_deleted,
        restore_points,
        s3,
        next_file_id >>

\* Create a new catalog restore point.
\*
\* A catalog can be "rolled back" to a state that contains one of these file
\* sets.
NewRestorePoint ==
    /\ restore_points' = restore_points \union {c_current}
    /\ has_restore_point' = TRUE
    /\ UNCHANGED <<
        c_current,
        c_deleted,
        snapshots,
        s3,
        next_file_id,
        since_snap >>

Init ==
    /\ c_current = {}
    /\ c_deleted = {}
    /\ restore_points = {}
    /\ snapshots = {}
    /\ since_snap = {}
    /\ s3 = {}
    /\ next_file_id = 0
    /\ has_restore_point = FALSE

Next ==
    \/ AddNewFile
    \/ TakeSnapshot
    \/ NewRestorePoint
    \/ SoftDeleteFile
    \/ GC_Catalog
    \/ GC_S3

Spec == Init /\ [][Next]_vars /\ WF_vars(Next)

----------------------------------------------------------------------------

\* All files referenced by all snapshots exist in S3 (Invariant 1).
AllSnapshotFilesExist == \A s \in snapshots: s \subseteq s3

\* All files in "interesting" catalog restore points exist in S3 (Invariant 2).
AllSnapshotsHaveMatchingRestorePoints ==
    \A s \in snapshots:
        \E p \in restore_points: p \subseteq s

\* All files in the catalog (inclusive of soft-deleted files) exist in S3.
AllFilesInCatalogExist == (c_current \union c_deleted) \subseteq s3

TypeOk ==
    /\ next_file_id \in 0..N
    /\ c_current \subseteq AllPossibleFiles
    /\ c_deleted \subseteq AllPossibleFiles
    /\ c_current \intersect c_deleted = {}
    /\ UNION restore_points \subseteq 0..next_file_id
    /\ UNION snapshots \subseteq 0..next_file_id
    /\ s3 \subseteq AllPossibleFiles
    /\ since_snap \subseteq 0..next_file_id
    /\ has_restore_point \in BOOLEAN

----------------------------------------------------------------------------

\* It is eventually always true that the model terminates (due to reaching the
\* model bound) and the set of files in S3 is equal to all files.
\*
\* Any system that allows file deletions should violate this property.
AllFilesRetained == <>[](s3 = AllPossibleFiles)

=============================================================================
\* Author: Dom <dom@itsallbroken.com>

